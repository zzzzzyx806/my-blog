---
title: Twenty Years of  Attacks on the RSA  Cryptosystem
date: 2024-10-19 17:58:46
tags:
---
## introduce RSA
- 介绍了 RSA 密码基本原理
	- 无法因式分解N时，枚举$Z^*_N$,时间复杂度为$O(N)$,没有讨论价值。
	- 要关注的是运行时间远小于N的算法,理想情况下这些算法的时间复杂度是 $O(n^c)$，其中 $n=log_⁡2N$，且常数 c 应该比较小（比如小于 5），这才是高效算法。
-  RSA 函数
	- 一种陷门单向函数，即容易计算但很难在没有私钥d的情况下反转。
	- 用于数字签名：签名者用私钥$⟨N,d⟩$进行签名，任何人都可用公钥验证签名，具体签名S为：$$S = M^d \mod N$$
- 分解因式 N 以解密
	- 目前分解大整数的最佳算法是 General Number Field Sieve ，时间复杂度为:$$\exp\left( (c + o(1))n^{1/3} (\log n)^{2/3} \right)$$
	- 如果 p−1 是小质数的乘积，则 N 容易被分解
	- **open problem 1** :是否必须进行因数分解才能破解 RSA ?给定 N 和加密指数 e ，我们能否在不分解 N 的情况下高效地计算出明文的 e 次根模 N？
	- **Fact 1**：知道私钥 d 和分解 N 等效，如果知道私钥 d，可以高效地对模数 N=pq 进行因数分解；反之，给定模数 N 的因数分解，也可以高效地恢复私钥 d。
		- 证明:设 $k=de−1$, k 是 $\phi(N$) 的倍数。
		  ϕ(N) 是偶数，因此 k 可以表示为 $k = 2^t r$，其中  r 是一个奇数，且 $t \geq 1$。
		  对于任意 $g \in Z^*_N$,$g^k≡1\mod N$,
		   x$≡1\ mod\ p$, $x \equiv -1 \mod q$,计算 $\text{gcd}(x - 1, N)$,d得到p或q
# elementary attacks
### Common Modulus（使用相同的N）
- 使用相同的模数 N=p\*q 为多个用户加密，为每个用户提供不同的公钥和私钥
- 表面上看，一个用户无法知道其他人的d，所以是安全的
- 事实上一个用户可以用他的e和d对N进行因式分解，从而在别人的e中知道别人的d
### Blinding(盲签名)
- 定义：即能够在不知道原始消息的情况下完成签名
- 实现过程：
	1. 选择一个随机数:$r \in \mathbb{Z}^*_N$
	2. 构造盲消息$M_0$:$M_0 = r^e M \mod N$
	3. 签名者在不知道原始消息 M 的情况下对$M_1$进行签名：$S_0 = M_0^d \mod N$
	4. 提取有效签名：$S =  S_0/r \mod N$
	   正确性：$S^e = ( S_0)^e/r^e\equiv  (M_0)^d/r^e\equiv  (r^e M)^d/r^e\equiv M \mod N$
# low private exponent attacks（d小）
为了减少解密时间，可能使用较小的 d ，但是 d 很小容易被使用 Wiener 定理轻松破解
### 维纳定理：
##### 满足
-  N = pq ，其中  q < p < 2q 。
- $d < \frac{1}{3} N^{1/4}$
- 已知公钥 (N,e)，且满足$ed \equiv 1 \mod \phi(N)$ 。
##### 则
攻击者可以有效地恢复私钥  d 。
#### 证明：
[Wiener's Attack Ride(维纳攻击法驾驭) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/400818185)
#### 如何应对：
1. 加大e的值:当$e_0>N^{1.5}$时，无论 d 有多小，上述攻击都无法实施。但是e增大加密时间就会增加。
2. 使用CRT:将d分为$d_p$和$d_q$分别进行解密再用CRT组合
- 首先，计算：$C_p = M^{d_p} \mod p$  , $C_q = M^{d_q} \mod q$ 。其中： $$d_p = d \mod (p - 1) , d_q = d \mod (q - 1)$$ 
- 然后，通过设置  $C = T_1 C_p + T_2 C_q \mod N$ 来获得签名或明文，其中$$T_1 = \begin{pmatrix} 1 \mod p \\ 0 \mod q \end{pmatrix},T_2 = \begin{pmatrix} 0 \mod p \\ 1 \mod q \end{pmatrix}$$
# low public exponent attacks（e小）
### Coppersmith定理
简言之，对于一个次数为d一元多项式$f(x)$，Coppersmith定理可以是在 $∣x_0∣<X$的范围内找到所有模N意义下的整数根
- 引理4：如果一个多项式 h(x) 的范数足够小（具体是$∥h(xX)∥<N/d$），那么该多项式模 N 的所有小根也是 h(x) 在整数上的根。
	- 具体$∣h(x₀)∣ = ∑ aᵢ x₀ⁱ ≤ ∑ ∣aᵢ∣ ∣x₀ⁱ∣$,（柯西$(∑ai​bi​)2≤(∑ai2​)(∑bi2​)$）

- 然后构造一个具有小范数并且与 f(x) 在模 N 下共享相同根的多项式 h(x)。具体是通过通过$f(x), x f(x), x^2 f(x)$, … 的整数线性组合，以及使用多项式 f(x) 的更高次幂模 $N^k$（即 $f(x)^k \mod N^k$）来形成多项式$g_{u,v}(x) = N^{m-v} x^u f(x)^v$
- 这些多项式被看为格子中的向量，通过LLL算法能找到格中的短向量
- open problem：能不能推广到多元？
### Hastad的广播攻击
此攻击适用于多个接收方同时使用RSA加密同一消息。假设所有接收方的公钥相同且加密指数相同（例如e=3），则攻击者可以利用这些加密文本恢复出原始消息。
- 基本Hastad攻击：$C2_1=M^3\mod N_2$,$C_2​=M^3\mod N_2$，可以用CRT得到$C0​=M3modN1​N2​N3$，又因为消息 M 小于每个 $N_i$​，因此 $M^3 < N_1N_2N_3$​，直接对C0取三次根就能恢复明文M
- 改进的Hastad攻击：每个人的M都经过了填充Mi​=i⋅2m+M 给每个接收者，试图让每个接收者收到的加密消息看起来不同。Hastad证明了这种“线性填充”是无效的，即便Bob在消息 M 前应用一个固定的多项式 $f_i(M)$，攻击者仍然可以恢复出原始消息 M。只要接收者数量 k 大于多项式的次数 d，攻击者就可以求解出 M。
- 如何抵御攻击：采用随机填充而非固定的填充
### Franklin-Reiter相关消息攻击
当使用相同的模数发送两个相关消息时，如果知道其中一个消息与另一个消息之间的关系，攻击者可以通过计算最大公约数（gcd）来恢复这两个消息，适用于小的公钥指数。
- 已知$M_1​=f(M_2​)modN$，即$M_1​=aM_2​+b$，我们用e=3进行举例
- 根据立方展开公式，我们可以得到： $C_1 = a^3M_2^3 + 3a^2bM_2^2 + 3ab^2M_2 + b^3 \mod N$
- 同时有$C_2​=M_2^3​modN$
- 设$C_2​=M_2^3​$，则可以构造$C_1​=a^3C_2​+3a^2bM_2^2​+3ab^2M_2​+b^3 \mod N$
- 从 $C_2$​ 解出 $M_2$，$M_2​=C_2^{1/3​}modN$就可以通过多项式关系 $M_1 = f(M_2)$ 来计算 $M_1$​
- 复杂度为$O((logN)2)$，面对小e时非常有效
### Coppersmith的短填充攻击
该攻击利用了加密过程中如果使用了不同的随机填充，攻击者可以通过分析两个相同消息的不同加密文本来恢复出原始消息。
- 已知：
	- N 是 n 位整数，消息 $M \in \mathbb{Z}_N$​ 的长度小于 n - m 位,m是填充位数
	- $M_1​=2^m M+r_1$​ 和 $M_2​=2^m M+r_2$​，其中 $r_1$ 和 $r_2$ 是随机填充，且 $r_1 \neq r_2$​，并满足 $0≤r1,r2<2^m$
- 攻击：
	- 定义两个多项式：$g_1​(x)=x^e−C_1​$和$g_2​(x,y)=(x+y)^e−C_2​$, x 是消息 $M_1$​，$y = r_2 - r_1$​，时这两个多项式有共同根
	- 结果式：$h(y) = \text{res}_x(g_1(x), g_2(x + y))$ ，这意味着 $h(y)$ 在 $y = r_2 - r_1$​ 处有根
	- 已知 $r_2​−r_1$​是一个**小根**，因为$|r_2 - r_1| < 2^m < N^{1/e^2}$。根据 Coppersmith 定理，可以通过求解 $h(y) = 0 \mod N$ 来找到这个小根 $y = r_2 - r_1$​。
	- 一旦知道了 $y = r_2 - r_1$​，可以使用 Franklin-Reiter 攻击的方法恢复 $M_1$ 和 $M_2$​，进而得到原始消息 M 。
### 部分密钥曝光攻击
当攻击者能够获取RSA私钥的一部分比特（例如四分之一）时，特别是在公钥较小时，可以重建整个私钥。
- 定理9（BDF）指出如果攻击者能够访问到 d 的最低有效位（具体是 n/4  位），并且公钥指数  $e < \sqrt{N}$，则可以重建整个 d。
- 定理10（Coppersmith）：如果你拥有质数 p 的最低有效 n/4 位或最高有效 n/4 位，你可以高效地分解 N。
# attacks on the implementation（攻击过程）
#### Timing Attacks(利用解密或签名的时间破解私钥)
- 背景：使用repeated squaring algorithm（重复平方算法）计算$C = M^d \mod N$
	- d的二进制表示为$d = d_n d_{n-1} \ldots d_0$
	- 设置$z = M$,$C = 1$
	- 对于每个$i = 0, \ldots, n$执行：
		- 如果  $d_i = 1$ 则计算 $C = C \cdot z \mod N$;如果$d_i=0$，则不进行计算。
		- 更新  $z = z^2 \mod N$ 。
- 攻击：在每一次迭代中，智能卡会根据当前位的值来决定是否计算某个乘积。如果$d=1$就计算，反之则不计算，根据每次计算的时间差异，判断d的哪一位是0还是1。
- 还可以进行功耗分析，进行多精度乘法时，智能卡的功耗会高于正常水平，通过测量高功耗周期的长度，攻击者可以确定在某次迭代中智能卡执行了多少次乘法，从而解d
- 应对方式：
	1. **固定延迟**: 添加适当的延迟，以确保模幂运算总是需要固定的时间。
	2. **盲签名**:选择一个随机数 $r \in Z^*_N$，$$M_0 = M \cdot r^e \mod N$$$$C_0 = (M_0)^d \mod N$$$$C = C_0 / r \mod N$$,这样就无法用上述方法攻击

#### Random Faults
在RSA解密和签名的实现中,通常使用CRT加速计算：
- 首先，计算：$C_p = M^{d_p} \mod p$  , $C_q = M^{d_q} \mod q$ 。其中： $$d_p = d \mod (p - 1) , d_q = d \mod (q - 1)$$ 
- 然后，通过设置  $C = T_1 C_p + T_2 C_q \mod N$ 来获得签名或明文，其中$$T_1 = \begin{pmatrix} 1 \mod p \\ 0 \mod q \end{pmatrix},T_2 = \begin{pmatrix} 0 \mod p \\ 1 \mod q \end{pmatrix}$$
假设在生成签名的过程中，算机由于故障导致单个指令的计算错误。
- 当$C_p$或$C_q$其中一个不正确，生成的签名$C_0$是错误的，攻击者可以判断出来，因为:$$C_0^e \neq M \mod N
$$
- 假设$C_q$出了错$$C_0^e \equiv M \mod p , C_0^e \not\equiv M \mod q$$
- 则$gcd(N,C_0^e−M)=p$
#### Bleichenbacher’s Attack on PKCS 1
- RSA 通常要求消息具有固定长度,长度不足时会被填充。PKCS #1 标准的旧版本中使用的填充格式如下： 02   随机数据   00   M
- 当攻击者拦截了一个密文，选择一个随机数$r \in \mathbb{Z}^*_N$进行尝试
- 某些应用程序会检查“02”初始块，如果不存在，它们会发回一条错误消息，指出“invalid ciphertext”，如果没有错误，他就推断解密后的消息 以"02" 开头
- 通过重复此过程并使用不同的 r 值，攻击者可以通过仔细分析机器的响应来缩小原始消息的可能值